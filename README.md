# objection-before-and-unique

[![Version](https://img.shields.io/github/package-json/v/rafamel/objection-before-and-unique.svg)](https://github.com/rafamel/objection-before-and-unique)
[![Build Status](https://travis-ci.org/rafamel/objection-before-and-unique.svg)](https://travis-ci.org/rafamel/objection-before-and-unique)
[![Coverage](https://img.shields.io/coveralls/rafamel/objection-before-and-unique.svg)](https://coveralls.io/github/rafamel/objection-before-and-unique)
[![Dependencies](https://david-dm.org/rafamel/objection-before-and-unique/status.svg)](https://david-dm.org/rafamel/objection-before-and-unique)
[![Vulnerabilities](https://snyk.io/test/npm/objection-before-and-unique/badge.svg)](https://snyk.io/test/npm/objection-before-and-unique)
[![Issues](https://img.shields.io/github/issues/rafamel/objection-before-and-unique.svg)](https://github.com/rafamel/objection-before-and-unique/issues)
[![License](https://img.shields.io/github/license/rafamel/objection-before-and-unique.svg)](https://github.com/rafamel/objection-before-and-unique/blob/master/LICENSE)

**Advanced unique validation + Simpler `before` API/checks for [Objection.js](http://vincit.github.io/objection.js/)**

## Install

[`npm install objection-before-and-unique`](https://www.npmjs.com/package/objection-before-and-unique)

## Usage

```javascript
const Model = require('objection').Model;
const beforeAndUnique = require('objection-before-and-unique');

// Once you mixin the Model like so, you'll be able to define
// `uniqueConstraints` and `beforeChecks` in your model
class MyModel extends beforeAndUnique(Model) {

    ...

    // Assert unique values for fields
    static get uniqueConstraints() {
        return [
            { col: 'username', label: 'User' },
            { col: 'email', label: 'Email', insensitive: true },
            { col: 'alias', for: ['team_id'], message: 'The alias is already taken'}
        ];
    }

    // Checks before insert and update
    static beforeChecks(newInstance, oldInstance) {
        return [
            async () => {
                // Do some async checks
                // Throw if it fails
                throw Error('Some Error');
            },
            () => {
                // Maybe some additional sync checks
                // Throw with a Model ValidationError
                throw Model.createValidationError({
                    someKey: [{
                        message: 'Some message',
                        keyword: 'unique'
                    }]
                });
            }
            },
            async () => {
                // Maybe mutate the object like so
                newInstance.hash = await someAsyncHashFunction(newInstance.pass);
                delete newInstance.pass;
            },
        ];
    }
}
```

### `uniqueConstraints`

Should return an Array of objects with keys:
- `col`: String. Column name to check for uniqueness.
- `label` (optional): String. How to name `col` in the response error message.
- `insensitive` (optional): Boolean. If `col` is a string, whether uniqueness should be evaluated as case insensitive.
- `for` (optional): Array of strings. Limits the query for uniqueness to rows that share the same `for` column values. If `{ col: 'alias', for: ['team_id'] }`, uniqueness is checked against all entried with the same `team_id` (`where team_id = ...`).
- `message` (optional): String. Substitutes the default error message.

Errors generated by the unique constraint failing will have keyword `unique`, if you so wish to catch them.

Only the first error will be returned (so if one of the queries fail, no further queries will execute). // chc

```javascript
static get uniqueConstraints() {
    return [
        { col: 'username', label: 'User' },
        { col: 'email', label: 'Email', insensitive: true },
        { col: 'alias', for: ['team_id'], message: 'The alias is already taken'}
    ];
}
```

### `beforechecks`

Takes two arguments:
- `newInstance`: New instance. Bear in mind, when it's a patch it might not have all the values.
- `oldInstance`: Previous Model instance when it's a patch or an update. `undefined` when it's an insert (as there is no previous instance).

Because of the way `Objection.js` works, [as it doesn't recover and pass the previous instance implicitly when doing patches or updates through `Model.query()` to `$beforeUpdate`](http://vincit.github.io/objection.js/#_s_beforeupdate), any [Model.query()](http://vincit.github.io/objection.js/#query) update/patch method will fail. In order to update/patch in Models using this plugins, you must recover the instance first, and do [`instance.$query()`](http://vincit.github.io/objection.js/#_s_query).

Should return an array of functions, optionally async/promise returning, and `throw` to fail. You can throw any error you please, but for consistency, it would be recommended that you use the built-in [`ValidationError`](http://vincit.github.io/objection.js/#validationerror) via [`Model.createValidationError()`](http://vincit.github.io/objection.js/#createvalidationerror).
